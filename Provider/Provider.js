/* Main file for the Provider functionalities */

// Express server to receive the requests
const Server = require('../Utils/Server')

// Handles requests
const Request = require('../Utils/Request')

// Platforms
const Platform = require('../Utils/Platform')

// Authentication
const Auth = require('../Utils/Auth')

// Utils
const url = require('url')
const low = require('lowdb')
const FileSync = require('lowdb/adapters/FileSync')
const Cryptr = require('cryptr');

//Pre-initiated variables
var loginUrl = "/login"
var appUrl = "/"
var keysetUrl = "/keys"
var ltiVersion = 1.3
var ENCRYPTIONKEY



/** Exposes methods for easy manipualtion of the LTI standard as a LTI Provider and a "server" object to manipulate the Express instance */
class Provider{

    /**
     * @description Exposes methods for easy manipualtion of the LTI standard as a LTI Provider and a "server" object to manipulate the Express instance.
     * @param {string} [_lti_version = "1.3"] - Valid versions are "1.1" and "1.3", it affects how the tool will comunicate with the consumer. Default value is "1.3".
     * @param {string} [_ENCRYPTIONKEY] - Encryption key to generate the db with platforms.
     
     */
    constructor(_lti_version, _ENCRYPTIONKEY){
        
        ENCRYPTIONKEY = _ENCRYPTIONKEY || "ltikey"

        if(_lti_version && (parseFloat(_lti_version) == 1.3 || parseFloat(_lti_version) == 1.1)) ltiVersion = parseFloat(_lti_version)
        
        this.server = new Server().app
    }

    /**
     * @description Starts listening to a given port for LTI requests
     * @param {number} port - The port the Provider should listen to
     */
    deploy(port){
        /* In case no port is provided uses 3000 */
        port = port || 3000

        if(ltiVersion == 1.3){
            /* Handles the login */
            this.server.post(loginUrl, (req, res)=>{
                
                //Remove AUTHENDPOINT and add mention to AUTH_CONFIG
                let platform = Platform.findPlatformWithUrl(req.body.iss, ENCRYPTIONKEY)
                
                
                if (platform) {
                    res.redirect(url.format({
                        pathname: platform.platformAuthEndpoint(),
                        query: Request.lti1_3Login(req.body, platform)
                    }))
                }
                else console.error("Unregistered platform attempting connection: " + req.body.iss)
            })

            
            this.server.post(appUrl, (req, res, next)=>{
                console.log("Receiving POST request on main app route. Attempting to decode IdToken...")
                //Decode and return the token to the user handler
                res.locals.id_token = req.body.id_token
                next()
            })


            this.server.get(keysetUrl, (req, res)=>{
                console.log("Sending public keyset...")
                let pb_adapter = new FileSync('./provider_data/publickeyset.json')
                let pb = low(pb_adapter)
                pb.defaults({keys: []}).write()

                res.json({keys: pb.get('keys').value()})
            })


        }

        

        
       
        //Starts server on given port
        this.server.listen(port, () => console.log("Lti Provider tool is listening on port " + port + "!\n\nLTI provider config: \n>Initiate login URL: " + loginUrl +"\n>App Url: " + appUrl + "\n>Lti Version: " + ltiVersion))
    }



    /**
     * @description Sets login Url responsible for dealing with the OIDC login flow. If no value is set "/login" is used.
     * @param {string} url - Login url.
     * @example provider.setLoginUrl('/login')
     */
    setLoginUrl(url){
        loginUrl = url
    }

    /**
     * @description Sets main application Url that will receive the final decoded Idtoken. If no value is set "/" (root) is used.
     * @param {string} url - App url.
     * @example provider.setAppUrl('/app')
     */
    setAppUrl(url){
        appUrl = url
    }

    /**
     * @description Sets keyset Url that will return a json containing a set of public keys. If no value is set "/keys" is used.
     * @param {string} url - Keyset url.
     * @example provider.setKeySetUrl('/keyset')
     */
    setKeySetUrl(url){
        keysetUrl = url
    }


    /**
     * @description Registers a platform.
     * @param {string} Url - Platform url.
     * @param {string} name - Platform nickname.
     * @param {string} client_id - Client Id generated by the platform.
     * @param {string} authentication_endpoint - Authentication endpoint that the tool will use to authenticate within the platform.
     * @param {object} [auth_config] - Authentication method and key for verifying messages from the platform. {method: "RSA_KEY", key:"PUBLIC KEY..."}
     */
    registerPlatform(url, name, client_id, authentication_endpoint, auth_config){
        if(!name || !url || !client_id || !authentication_endpoint) {
            console.error("Error registering platform. Missing argument.")
            return false
        }
        if(!Platform.findPlatformWithUrl(url, ENCRYPTIONKEY)){
            let kid = Auth.generateProviderKeyPair()
            return new Platform(name, url, client_id, authentication_endpoint, kid, ENCRYPTIONKEY, auth_config)
        }else{
            console.error("Platform already registered. Url: " + url)
        }
        
    }

    /**
     * @description Gets a platform.
     * @param {string} url - Platform url.
     */
    getPlatform(url){
        if(!url) return false
        return Platform.findPlatformWithUrl(url, ENCRYPTIONKEY)
    }


    /**
     * @description Gets a platform.
     * @param {string} url - Platform url.
     */
    deletePlatform(url){
        if(!url) return false
        let platform = Platform.findPlatformWithUrl(url, ENCRYPTIONKEY)
        if(platform) return platform.remove()
    }


    /**
     * @description Gets all platforms.
     */
    getAllPlatforms(){
        let cryptr = new Cryptr(ENCRYPTIONKEY)
        let adapter = new FileSync('./provider_data/platforms.json', {
            serialize: (data) => cryptr.encrypt(JSON.stringify(data)),
            deserialize: (data) => JSON.parse(cryptr.decrypt(data))
          })
        let db = low(adapter)
        
        db.defaults({ platforms: []}).write()
        return db.get('platforms').value()
    }


    


}
module.exports = Provider